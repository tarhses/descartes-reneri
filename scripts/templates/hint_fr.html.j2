  <p class="issue">
    Le corps de la méthode {{ mutation|method_link }} a été
    {# The body of the method {{ mutation|method_link }} was #}
{% if mutation.mutator == 'void' %}
    supprimé
    {# removed #}
{% else %}
    remplacé par
    {# replaced by #}
  {% if mutation.mutator == 'empty'%}
    un <code>return</code> renvoyant une liste vide.
    {# a single <code>return</code> producing an empty array #}
  {% else %}
    <code>return {{ mutation.mutator }};</code>.
    {# <code>return {{ mutation.mutator }};</code> #}
  {% endif %}
{% endif %}
    Cependant,
    {# yet, #}
{% if mutation.tests|length == 1 %}
    le test {{ mutation.tests[0] }} n'a pas échoué.
    {# {{ mutation.tests[0] }} did not fail. #}
{% else %}
    aucun des tests suivants n'a échoué&nbsp;:
    {# none of the following tests failed: #}
    <ul>
  {% for test in mutation.tests %}
      <li>{{ test|test_case_link }}</li>
  {% endfor %}
    </ul>
{% endif %}
  </p>
{% if hint.type == 'execution' %}
  <p class="diagnosis">
    Lors de l'exécution de la méthode modifiée, aucune différence n'a été
    observée par rapport à la méthode originale.
    {# When the transformed method is executed, there is no difference with the
    execution using the original source code. #}
  </p>
  <p class="suggestion">
  {% if mutation.is_void %}
    Cela pourrait dire que la méthode ne produit aucun effet de bord dans aucun
    test.
    {# This could mean that the method is not producing any side effect. #}
    Vous pourriez essayer de créer une variante
    {# Consider creating a modified variant of the #}
    {% if mutation.tests|length == 1 %}
    du test en question
    {# test mentioned #}
    {% else %}
    des tests listés ci-dessus
    {# tests listed #}
    {% endif %}
    afin de rendre les effets de bord observables.
    {# above where the side effects can be observed. #}
  {% else %}
    Cela pourrait dire que la méthode originale renvoit toujours la même valeur
    dans les tests actuels.
    {# This could mean that the original method always returns the same value. #}
    Vous pourriez essayer de créer une variante
    {# Consider creating a modified variant of the #}
    {% if mutation.tests|length == 1 %}
    du test mentionné
    {# test mentioned #}
    {% else %}
    des tests listés
    {# tests listed #}
    {% endif %}
    ci-dessus dans laquelle la méthode renverrait une valeur différente.
    {# above to make the method produce a different value. #}
  {% endif %}
  </p>
{% elif hint.type == 'observation' %}
  {% set location = hint.location %}
  <p class="diagnosis">
    Il est possible d'observer une différence dans l'exécution du programme
    lorsque la méthode transformée est utilisée à la place de la méthode
    originale.
    {# It is possible to observe a difference between the program state when the
    transformed method is executed and the program state when the original
    method is executed. #}
    Cette différence peut être observée dans {{ location|location_link }}
    depuis l'expression qui renvoie une valeur de type
    <code>{{ location.type }}</code>
    {# This difference can be observed in {{ location|location_link }} from
    the expression returning a value of type <code>{{ location.type }}</code> located #}
  {% if location.from.line == location.to.line %}
    (ligne {{ location.from.line }}).
    {# in line {{ location.from.line }} from column {{ location.from.column }}
    to column {{ location.to.column }}. #}
  {% else %}
    (lignes {{ location.from.line }} à {{ location.to.line }}).
    {# from line {{ location.from.line }} and column
    {{ location.from.column }} to line {{ location.to.line }}. #}
  {% endif %}
  {% if not diff %}
  </p>
  {% else %}
    {% set pointcut = diff.pointcut %}
    Lorsque la transformation est appliquée à la méthode, la valeur
    {# When the transformation is applied to the method, it was observed that #}
    {% if pointcut.exception %}
    de l'exception
    {# the exception thrown in the test #}
    {% else %}
      {% if pointcut.size %}
    de la longueur (<code>.size()</code>)
    {# the size of #}
      {% elif pointcut.length %}
    de la taille (<code>.length</code>)
    {# the length of #}
      {% endif %}
      {% if pointcut.field %}
    du champ <code>{{ pointcut.field }}</code>
    {# the field <code>{{ pointcut.field }}</code> of #}
      {% endif %}
    {% endif %}
    est {{ diff.observed|describe }} au lieu de {{ diff.expected|describe }}.
    {# the value obtained from the expression was {{ diff.observed|describe }}
    but should have been {{ diff.expected|describe }}. #}
  </p>
  <p class="suggestion">
    {% if pointcut.field and not hint|attr("targets") %}
    Vous pourriez essayer de modifer le test et d'ajouter une assertion qui
    cible <code>{{ pointcut.field }}</code>.
    {# Consider modifying the test to verify the value of
    <code>{{ pointcut.field }}</code> in the result of the expression. #}
    {% endif %}
    {% if hint.targets %}
    Voici la liste des méthodes liées dont vous pourriez vérifier le résulat ou
    les effets de bord&nbsp;:
    {# Consider verifying the result or side effects of one of the following
    methods invoked for the result of the expression: #}
    <ul>
      {% for method in hint.targets %}
      <li><code>{{ method }}</code></li>
      {% endfor %}
    </ul>
    {% endif %}
  </p>
  {% endif %}
{% elif hint.type == 'infection' %}
  <p class="diagnosis">
    Il est possible d'observer une différence dans l'exécution du programme
    lorsque la méthode transformée est utilisée à la place de la méthode
    originale. Cette différence est observable dans une méthode mais pas dans
    les tests.
    {# It is possible to observe a difference between the program state when the
    transformed method is executed and the program state when the original
    method is executed. This difference is observed right after the method
    invocation but not from from the top level code of any test. #}
  {% if diff %}
    {% set pointcut = diff.pointcut %}
    En exécutant <code>{{ mutation.method }}</code>, la valeur
    {# For one invocation of <code>{{ mutation.method }}</code>, it was observed that #}
    {% if pointcut.size %}
    de la taille (<code>.size()</code>)
    {# the size of #}
    {% elif pointcut.length %}
    de la longueur (<code>.length</code>)
    {# the length of #}
    {% endif %}
    {% if pointcut.field %}
    du champ <code>{{ pointcut.field }}</code>
    {# the field <code>{{ pointcut.field }}</code> of #}
    {% endif %}
    {% if pointcut.result %}
    de la valeur renvoyée
    {# the return value #}
    {% elif pointcut.that %}
    de l'objet sur lequel la méthode est appelée
    {# the instance in which the method was called #}
    {% else %}
    du {{ pointcut.argument + 1 }}<sup>e</sup> paramètre
    {# {{ pointcut.argument + 1|ordinal }} argument #}
    {% endif %}
    est {{ diff.observed|describe }} au lieu de {{ diff.expected|describe }}.
    {# was {{ diff.observed|describe }} but should have been {{ diff.expected|describe }}. #}
  {% endif %}
  </p>
  <p class="suggestion">
    Pour résoudre ce problème, vous pourriez&nbsp;:
    {# To solve this problem you may consider to: #}
    <ul>
  {% if hint.direct_access %}
      <li>
        Créer un nouveau test qui cible directement le résultat de
        <code>{{ mutation.method }}</code>, car cette méthode est accessible
        depuis les tests.
        {# Create a new test case that targets the result of <code>{{ mutation.method }}</code>
        directly, since it could be accessed from a test class. #}
      </li>
  {% else %}
      <li>
        Créer un nouveau test qui cible le résultat d'une de ces méthodes&nbsp;:
        {# Create a new test case that targets the result of one of the following methods: #}
        <ul>
    {% for method in hint.targets %}
          <li>{{ method }}</li>
    {% endfor %}
        </ul>
        En effet, ces méthodes peuvent être utilisées pour déclencher
        indirectement l'exécution de <code>{{ mutation.method }}</code>.
        {# these are the closest accessible methods that can be used to trigger the
        execution of <code>{{ mutation.method }}</code>. #}
      </li>
      <li>
        Vérifier si les effets de la méthode sont visibles en dehors de la
        classe. Si ce n'est pas le cas, vous pourriez essayer d'ajouter une
        méthode (peut-être un accesseur) pour pouvoir observer les effets de
        <code>{{ mutation.method }}</code>.
        {# Check if the effects of the method are visible from outside the class.
        Otherwise you may consider to add a visible method (maybe a getter) that
        could be used to observe the effects of <code>{{ mutation.method }}</code>. #}
      </li>
  {% endif %}
      <li>
        Refactorer le code qui appelle cette méthode. Peut-être qu'elle n'est
        pas réellement nécessaire dans ce contexte.
        {# Refactor the code that uses this method. Maybe the method is not actually
        needed in the context that it is being used. #}
      </li>
    </ul>
  </p>
{% endif %}
